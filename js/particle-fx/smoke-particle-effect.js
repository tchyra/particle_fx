var _DEBUG_counter = 100;

class Vector {

    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }

    add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }

    plus(v) {
        return new Vector(this.x + v.x, this.y + v.y);
    }

    subtract(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }

    minus(v) {
        return new Vector(this.x - v.x, this.y - v.y);
    }

    multiply(n) {
        this.x *= n;
        this.y *= n;
        return this;
    }

    times(n) {
        return new Vector(this.x * n, this.y * n);
    }

    divide(n) {
        this.x /= n;
        this.y /= n;
        return this;
    }

    dividedBy(n) {
        return new Vector(this.x / n, this.y / n);
    }

    _sqr(n) { return n * n; }

    distSqr(v) {
        return this._sqr(this.x - v.x) + this._sqr(this.y - v.y);
    }

    dist(v) {
        return Math.sqrt(this.distSqr(v));
    }

    getMagSqr() {
        return this.x * this.x + this.y * this.y;
    }

    getMag() {
        return Math.sqrt(this.getMagSqr());
    }

    normalize() {
        return this.divide(this.getMag());
    }

    normalized() {
        return this.dividedBy(this.getMag());
    }

    dirTo(v) {
        return v.minus(this).normalize();
    }
}

class AudioPoint {

    constructor(x, size, color) {
        this.x = x;
        this.offsetY = 0;
        this.size = size;
        this.color = color;
    }

    draw(ctx, baseY) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, baseY + this.offsetY, this.size, 0, 2 * Math.PI, false);
        ctx.fill();
    }

}

class CableSegment {

    constructor(n1, n2, k, damping, baseLength) {
        this.n1 = n1;
        this.n2 = n2;
        this.k = k;
        this.damping = damping;
        this.baseLength = baseLength;
    }

    calculatePhysics(deltaTimeS, backwards) {

        let srcN, destN;

        if (backwards) {
            srcN = this.n2;
            destN = this.n1;
        } else {
            srcN = this.n1;
            destN = this.n2;
        }

        let currLength = this.n1.pos.dist(this.n2.pos)
        let deltaLen = this.baseLength - currLength;

        // force generated by the spring
        destN.addForce(srcN.pos.dirTo(destN.pos).multiply(deltaLen * k))
        destN.calculatePhysics(deltaTimeS);

        this.n2.addForce(-this.offsetY * k);
        // damping force (proportional to velocity)
        this.addForce(-this.velY * damping);

    }

    draw(ctx, width, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.beginPath();
        ctx.moveTo(this.n1.pos.x, this.n1.pos.y);
        ctx.lineTo(this.n2.pos.x, this.n2.pos.y);
        ctx.stroke();
    }

}

class CableNode {

    constructor(pos, mass, size, color) {
        this.pos = pos;
        this.force = new Vector();
        this.tempForce = new Vector();
        this.vel = new Vector();
        this.mass = mass;
        this.size = size;
        this.color = color;
    }

    addForce(f) {
        this.force.add(f);
    }

    addTempForce(f) {
        this.tempForce.add(f);
    }

    calculateTempPhysics(deltaTimeS) {
        this.tempVel = this.vel.plus(this.tempForce.multiply(deltaTimeS * this.mass));
        this.tempPos = this.pos.plus(this.tempVel.times(deltaTimeS));
    }

    calculatePhysics(deltaTimeS) {
        this.vel.add(this.force.multiply(deltaTimeS * this.mass));
        this.pos.add(this.vel.times(deltaTimeS));
        this.force = new Vector();
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.size, 0, 2 * Math.PI, false);
        ctx.fill();
    }


}

class AudioCablesParticleEffect extends ParticleEnv {

    static getDefaultSimulationParams() {
        return {
            audioPoints: {
                count: 10,
                size: 5,
                spacing: 150,
                colorRange: new ColorRange('#333333', '#ffffff'),
                maxVolumeOffsetY: 400
            },
            cables: {
                nodes: {
                    countPerSegment: 10,
                    mass: 1,
                    size: 2
                },
                segments: {
                    baseLengthMultiplier: 1,
                    k: 380,
                    damping: 5.5,
                    width: 1.5,
                    pullOnly: true,
                    maxForce: 1000
                },
                gravityForce: 1800
            },
            floor: {
                color: '#444',
                height: 2
            },
            audio: {
                sampleCutoff: 200
            }
        };
    }

    constructor(targetCnv, params) {
        super(targetCnv, params);
        this._dragging = false;
    }

    _drawLine(color, a, b, c, d) {

        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 2;

        this.ctx.beginPath();

        if (typeof a === 'number') {

            if (typeof c === 'number') {
                this.ctx.moveTo(a, b);
                this.ctx.lineTo(c, d);
            } else {
                this.ctx.moveTo(a, b);
                this.ctx.lineTo(c.x, c.y);
            }

        } else if (typeof b === 'number') {

            this.ctx.moveTo(a.x, a.y);
            this.ctx.lineTo(b, c);

        } else {

            this.ctx.moveTo(a.x, a.y);
            this.ctx.lineTo(b.x, b.y);

        }

        this.ctx.stroke();
    }

    createCanvasEventHandlers() {

        this.audioEl = document.getElementById('audio');
        this.audioEl.addEventListener('play', ev => {

            if (!this.audioStarted) {
                this._setupAudio();
            }

        });

    }

    _setupAudio() {

        // audio setup
        // https://medium.com/swlh/building-a-audio-visualizer-with-javascript-324b8d420e7
        this.audioCtx = new AudioContext();

        this.audioAnalyser = this.audioCtx.createAnalyser();
        this.audioAnalyser.fftSize = 2048;

        this.audioSource = this.audioCtx.createMediaElementSource(this.audioEl);
        this.audioSource.connect(this.audioAnalyser);
        this.audioSource.connect(this.audioCtx.destination);
        this.audioData = new Uint8Array(this.audioAnalyser.frequencyBinCount);

        this.freqCountPerParticle = Math.floor(Math.min(this.params.audio.sampleCutoff, this.audioData.length) / this.audioPoints.length);

        this.audioStarted = true;
    }

    start() {

        const startX = (this.cnvw - this.params.audioPoints.spacing * (this.params.audioPoints.count - 1)) / 2;

        const cableSegmentCount = this.params.cables.nodes.countPerSegment + 1;
        const cableNodeCount = this.params.cables.nodes.countPerSegment + 2;

        const cableSegmentStartLength = this.params.audioPoints.spacing / cableSegmentCount;
        const cableSegmentBaseLength = cableSegmentStartLength * this.params.cables.segments.baseLengthMultiplier;

        this.audioPoints = new Array(this.params.audioPoints.count);
        this.cableNodes = new Array(this.params.audioPoints.count - 1);
        this.cableSegments = new Array(this.params.audioPoints.count - 1);

        // create particles
        for (let i = 0; i < this.params.audioPoints.count; i++) {

            // create audio points
            this.audioPoints[i] = new AudioPoint(
                startX + this.params.audioPoints.spacing * i,
                this.params.audioPoints.size,
                this.params.audioPoints.colorRange.roll()
            );

            // create cable points for the previous audio point from 2nd point on
            if (i > 0) {

                let currAudioPointI = i - 1;
                let currAudioPoint = this.audioPoints[currAudioPointI];
                let nextAudioPoint = this.audioPoints[i];

                // interpolate colour between current and next audio points
                let colRange = new ColorRange(currAudioPoint.color, nextAudioPoint.color);

                // create cable nodes and segments subarrays
                this.cableNodes[i - 1] = new Array(cableNodeCount);
                this.cableSegments[i - 1] = new Array(cableSegmentCount);

                for (let j = 0; j < cableNodeCount; j++) {

                    // create cable node
                    this.cableNodes[currAudioPointI][j] = new CableNode(
                        new Vector(startX + currAudioPointI * this.params.audioPoints.spacing + j * cableSegmentStartLength, this.baseY),
                        this.params.cables.nodes.mass,
                        this.params.cables.nodes.size,
                        colRange.lerp(j / cableNodeCount)
                    );

                    if (j > 0) {
                        // create a segment between prev node and curr cable nodes
                        this.cableSegments[currAudioPointI][j - 1] = new CableSegment(
                            this.cableNodes[currAudioPointI][j - 1],
                            this.cableNodes[currAudioPointI][j],
                            this.params.cables.segments.k,
                            this.params.cables.segments.damping,
                            cableSegmentBaseLength
                        );
                    }

                }
            }
        }
    }

    frame(deltaTime, deltaTimeS, frameNo) {

        // skip the frame if more than 500ms elapsed since the last frame, the most likely cause of this is slowing animation framerate when the browser window is in the background.
        if (deltaTime > 500) return;
        this.ctx.clearRect(0, 0, this.cnvw, this.cnvh); // clear the canvas

        this._drawLine(this.params.floor.color, 0, this.baseY, this.cnvw, this.baseY);

        let freqCountPerParticle

        if (this.audioStarted)
            // get audio data for this frame
            this.audioAnalyser.getByteFrequencyData(this.audioData);

        let p;
        for (let i = 0; i < this.audioPoints.length; i++) {
            p = this.audioPoints[i];

            let freqSum = 0, avgFreq = 0;

            if (this.audioStarted) {

                for (var j = 0; j < this.freqCountPerParticle; j++) {
                    freqSum += this.audioData[i * this.freqCountPerParticle + j];
                }

                avgFreq = freqSum / this.freqCountPerParticle;
            }

            // calculate y offset for the current audio point
            p.offsetY = -avgFreq / 255 * this.params.audioPoints.maxVolumeOffsetY;

            // draw audio point
            p.draw(this.ctx, this.baseY);
            // draw line from audio point to floor
            this._drawLine(p.color, p.x, this.baseY + p.offsetY, p.x, this.baseY);

            if (i < this.audioPoints.length - 1)
                // apply audio point y position to first cable node
                this.cableNodes[i][0].pos.y = this.baseY + p.offsetY;

            // work on cable segments if this isn't the first audio point
            if (i > 0) {

                // apply audio point y position to last cable node of previous cable
                this.cableNodes[i - 1][this.params.cables.nodes.countPerSegment + 1].pos.y = this.baseY + p.offsetY;

                // loop through every segment aside from the last one, applying physics forward

                // prev node is the first node
                let prevNodePos = this.cableNodes[i - 1][0].pos;
                let gravityForce = new Vector(0, this.params.cables.gravityForce);

                for (let j = 1; j < this.params.cables.nodes.countPerSegment + 1; j++) {

                    let node = this.cableNodes[i - 1][j];
                    let seg = this.cableSegments[i - 1][j - 1];

                    node.tempForce = new Vector();

                    // add gravity force
                    node.addTempForce(gravityForce.times(node.mass));
                    node.addForce(gravityForce.times(node.mass));

                    let segLength = prevNodePos.dist(node.pos)
                    let deltaLen = segLength - seg.baseLength;

                    // force generated by the spring
                    if (!this.params.cables.segments.pullOnly || deltaLen > 0) {
                        let springForce = prevNodePos.dirTo(node.pos).multiply(-deltaLen * seg.k);
                        node.addTempForce(springForce);
                        node.addForce(springForce);
                    }

                    // calculate tempVel and tempPos
                    node.calculateTempPhysics(deltaTimeS);

                    // add damping force (proportional to tempVel)
                    let dampingForce = node.tempVel.times(-seg.damping);
                    node.addForce(dampingForce)

                    // update prev node pos this node's
                    prevNodePos = node.tempPos;
                }

                // loop backwards through every segment aside from the first one, applying forces backwards and calculating final forces

                // prev node is the last one
                prevNodePos = this.cableNodes[i - 1][this.params.cables.nodes.countPerSegment + 1].pos;

                for (let j = this.params.cables.nodes.countPerSegment; j > 0; j--) {

                    let node = this.cableNodes[i - 1][j];
                    let seg = this.cableSegments[i - 1][j - 1];

                    let segLength = prevNodePos.dist(node.pos)
                    let deltaLen = segLength - seg.baseLength;

                    // clear forces from previous pass
                    node.tempForce = new Vector();

                    // add gravity force again, but only temp
                    node.addTempForce(gravityForce.times(node.mass));

                    // force generated by the spring
                    if (!this.params.cables.segments.pullOnly || deltaLen > 0) {
                        let springForce = prevNodePos.dirTo(node.pos).multiply(-deltaLen * seg.k);
                        node.addTempForce(springForce);
                        node.addForce(springForce);
                    }

                    // calculate tempVel and tempPos
                    node.calculateTempPhysics(deltaTimeS);

                    // add damping force (proportional to tempVel)
                    let dampingForce = node.tempVel.times(-seg.damping);
                    node.addForce(dampingForce);

                    // update prev node pos this node's
                    prevNodePos = node.tempPos;

                    // apply final force and calculate physics for real
                    node.calculatePhysics(deltaTimeS);
                }

                // loop through every node and segment to draw them
                for (let j = 0; j < this.params.cables.nodes.countPerSegment + 2; j++) {

                    if (j < this.params.cables.nodes.countPerSegment + 1)
                        this.cableSegments[i - 1][j].draw(this.ctx, this.params.cables.segments.width, this.cableNodes[i - 1][j].color);

                    this.cableNodes[i - 1][j].draw(this.ctx);

                }

            }
        }
    }

    resize() {
        this.centerX = this.cnvw / 2;
        this.centerY = this.cnvh / 2;
        this.baseY = this.centerY + this.params.audioPoints.maxVolumeOffsetY / 2;
    }

    restart() {
        super.restart();
    }
}
