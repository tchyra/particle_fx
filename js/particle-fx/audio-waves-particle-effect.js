
class AudioWavesParticle {

    constructor(x, baseY, size, color) {
        this.x = x;
        this.baseY = baseY;
        this.offsetY = 0;
        this.size = size;
        this.mass = 1;
        this.vy = 0;
        this.forceY = 0;
        this.velY = 0;
        this.color = color;
    }

    get y() {
        return this.baseY + this.offsetY;
    }

    addForce(y) {
        this.forceY += y;
    }

    addElasticForces(k, damping) {
        // force generated by the spring
        this.addForce(-this.offsetY * k);
        // damping force (proportional to velocity)
        this.addForce(-this.velY * damping);
    }

    updatePhysics(deltaTimeS) {
        this.velY += this.forceY * this.mass * deltaTimeS;
        this.offsetY += this.velY * deltaTimeS;
        this.forceY = 0;
    }

    draw(ctx) {

        ctx.fillStyle = this.color;
        //ctx.fillRect(x - this.size / 2, (baseY + this.offsetY) - this.size / 2, this.size, this.size);
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI, false);
        ctx.fill();
    }

}

class AudioWavesParticleEffect extends ParticleEnv {

    static getDefaultSimulationParams() {
        return {
            particles: {
                count: 40,
                size: 4,
                spacing: 25,
                colorRange: new ColorRange('#888888', '#ffffff'),
                colorOffsetYRange: new Range(-50, 50),
                maxVolumeOffsetY: 200,
            },
            mesh: {
                color: Color.fromHex('#999999'),
                width: 2
            },
            returnSpring: {
                k: 40,
                damping: 3
            },
            neighborSpring: {
                k: 40,
                damping: 2
            },
            audio: {
                sampleCutoff: 220
            }
        };
    }

    constructor(targetCnv, params) {
        super(targetCnv, params);
        this._dragging = false;
    }

    _setupAudio() {

        // audio setup
        // https://medium.com/swlh/building-a-audio-visualizer-with-javascript-324b8d420e7
        this.audioCtx = new AudioContext();

        this.audioAnalyser = this.audioCtx.createAnalyser();
        this.audioAnalyser.fftSize = 2048;

        this.audioSource = this.audioCtx.createMediaElementSource(this.audioEl);
        this.audioSource.connect(this.audioAnalyser);
        this.audioSource.connect(this.audioCtx.destination);
        this.audioData = new Uint8Array(this.audioAnalyser.frequencyBinCount);

        this.audioStarted = true;
    }

    createCanvasEventHandlers() {

        this.audioEl = document.getElementById('audio');
        this.audioEl.addEventListener('play', ev => {

            if (!this.audioStarted) {
                this._setupAudio();
            }

        });

        this.cnv.addEventListener('mousedown', ev => this.onMouseDown(ev));
        window.addEventListener('mousemove', ev => this.onMouseMove(ev));
        window.addEventListener('mouseup', ev => this.onMouseUp(ev));
    }

    start() {

        let startX = (this.cnvw - this.params.particles.spacing * this.params.particles.count) / 2;
        let currX = startX;

        this.particles = new Array(this.params.particles.count);

        // create particles
        for (var i = 0; i < this.params.particles.count; i++) {
            this.particles[i] = new AudioWavesParticle(currX, this.cnvh / 2, this.params.particles.size, this.params.particles.colorRange.roll());
            currX += this.params.particles.spacing;
        }
    }

    frame(deltaTime, deltaTimeS, frameNo) {

        // skip the frame if more than 500ms elapsed since the last frame, the most likely cause of this is slowing animation framerate when the browser window is in the background.
        if (deltaTime > 500) return;

        this.ctx.clearRect(0, 0, this.cnvw, this.cnvh); // clear the canvas

        this.ctx.strokeStyle = this.params.mesh.color;
        this.ctx.lineWidth = this.params.mesh.width;
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.cnvh / 2);
        this.ctx.lineTo(this.cnvw, this.cnvh / 2);
        this.ctx.stroke();

        // get audio data for this frame
        if (this.audioStarted) {

            this.audioAnalyser.getByteFrequencyData(this.audioData);

            let freqCountPerParticle = Math.floor(Math.min(this.params.audio.sampleCutoff, this.audioData.length) / this.particles.length);

            this.ctx.strokeStyle = this.params.mesh.color;
            this.ctx.lineWidth = this.params.mesh.width;
            this.ctx.beginPath();

            let p;
            for (let i = 0; i < this.particles.length; i++) {
                p = this.particles[i];

                let freqSum = 0;

                for (var j = 0; j < freqCountPerParticle; j++) {
                    freqSum += this.audioData[i * freqCountPerParticle + j];
                }

                let avgFreq = freqSum / freqCountPerParticle;

                p.offsetY = -avgFreq / 255 * this.params.particles.maxVolumeOffsetY;

                if (i === 0)
                    this.ctx.moveTo(p.x, p.y);
                else
                    this.ctx.lineTo(p.x, p.y);
            }

            this.ctx.stroke();

            for (let i = 0; i < this.particles.length; i++) {
                p = this.particles[i];

                this.ctx.strokeStyle = p.color;
                this.ctx.lineWidth= this.params.mesh.width;
                this.ctx.beginPath();
                this.ctx.moveTo(p.x, p.y);
                this.ctx.lineTo(p.x, this.cnvh / 2);
                this.ctx.stroke();

                p.draw(this.ctx);
            }

        }
    }

    drawLine(color, p1, p2) {

        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = 2;

        this.ctx.beginPath();
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.stroke();
    }

    resize() {
        this.centerX = this.cnvw / 2;
        this.centerY = this.cnvh / 2;
    }

    restart() {
        super.restart();
    }

    onMouseDown(ev) {
        this._dragging = true;
        this._dragStartY = ev.clientY;
    }

    onMouseMove(ev) {
        if (this._dragging) {
            let delta = ev.clientY - this._dragStartY;
            this.particles[0].offsetY = delta;
        }
    }

    onMouseUp(ev) {
        this._dragging = false;
    }
}
