
class WavesParticle {

    constructor(x, startY, size, color) {
        this.x = x;
        this.startY = startY;
        this.offsetY = 0;
        this.size = size;
        this.mass = 1;
        this.vy = 0;
        this.forceY = 0;
        this.velY = 0;
        this.color = color;
    }

    addForce(y) {
        this.forceY += y;
    }

    addElasticForces(k, damping) {
        // force generated by the spring
        this.addForce(-this.offsetY * k);
        // damping force (proportional to velocity)
        this.addForce(-this.velY * damping);
    }

    updatePhysics(deltaTimeS) {
        this.velY += this.forceY * this.mass * deltaTimeS;
        this.offsetY += this.velY * deltaTimeS;
        this.forceY = 0;
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.size / 2, (this.startY + this.offsetY) - this.size / 2, this.size, this.size);
    }

}

class WavesParticleEffect extends ParticleEnv {

    static getDefaultSimulationParams() {
        return {
            particles: {
                count: 12,
                size: 20,
                spacing: 100,
                colorRange: new ColorRange('#11c5fc', '#115cfc')
            },
            returnSpring: {
                k: 40,
                damping: 3
            },
            neighborSpring: {
                k: 25,
                damping: 1
            }
        };
    }

    constructor(targetCnv, params) {
        super(targetCnv, params);
        this._dragging = false;
    }

    createCanvasEventHandlers() {
        this.cnv.addEventListener('mousedown', ev => this.onMouseDown(ev));
        window.addEventListener('mousemove', ev => this.onMouseMove(ev));
        window.addEventListener('mouseup', ev => this.onMouseUp(ev));
    }

    start() {

        this.particles = new Array(this.params.particles.count);

        let totalSpacing = (this.params.particles.count - 1) * this.params.particles.spacing;
        let startX = (this.cnvw - totalSpacing) / 2;
        let currX = startX;
        let startY = this.cnvh / 2;

        // create particles
        for (var i = 0; i < this.params.particles.count; i++) {

            this.particles[i] = new WavesParticle(currX, startY, this.params.particles.size, this.params.particles.colorRange.roll());
            currX += this.params.particles.spacing;
        }
    }

    frame(deltaTime, deltaTimeS, frameNo) {

        // skip the frame if more than 500ms elapsed since the last frame, the most likely cause of this is slowing animation framerate when the browser window is in the background.
        if (deltaTime > 500) return;

        this.ctx.clearRect(0, 0, this.cnvw, this.cnvh); // clear the canvas

        let p;
        for (var i = 0; i < this.particles.length; i++) {

            p = this.particles[i];

            if (!this._dragging || i > 0) {
                p.addElasticForces(this.params.returnSpring.k, this.params.returnSpring.damping);
            }

            if (i > 0) {
                let deltaY = p.offsetY - this.particles[i - 1].offsetY;
                // force generated by the spring
                p.addForce(-deltaY * this.params.neighborSpring.k);
                p.addForce(-p.velY * this.params.neighborSpring.damping);
            }

            p.updatePhysics(deltaTimeS);

            p.draw(this.ctx);
        }
    }

    restart() {
        super.restart();
    }

    onMouseDown(ev) {
        this._dragging = true;
        this._dragStartY = ev.clientY;
    }

    onMouseMove(ev) {
        if (this._dragging) {
            let delta = ev.clientY - this._dragStartY;
            this.particles[0].offsetY = delta;
        }
    }

    onMouseUp(ev) {
        this._dragging = false;
    }
}
